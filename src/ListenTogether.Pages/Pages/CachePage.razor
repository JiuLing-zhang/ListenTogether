@page "/cache"
@using ListenTogether.EasyLog
@inject IDialogService DialogService

<div class="page">

    @if (_cacheLength == null)
    {
        <div class="d-flex flex-column align-center mt-5">
            <MudSkeleton SkeletonType="SkeletonType.Circle" Width="200px" Height="200px" />
            <div class="d-flex align-center mt-5">
                <MudProgressCircular Size="Size.Small"
                                     Indeterminate="true" />
                <MudText Typo="Typo.caption"
                         Class="ml-2">
                    正在计算
                </MudText>
            </div>
        </div>
    }
    else
    {
        <div class="d-flex flex-column align-center mt-5">
            <div class="cache-size d-flex flex-column align-center justify-center">
                <MudText Typo="Typo.subtitle2">
                    发现缓存
                </MudText>
                <MudText Typo="Typo.h6">
                    @($"{_cacheLength / 1024 / 1024:N2}")
                </MudText>
                <MudText Typo="Typo.subtitle2">
                    MB
                </MudText>
            </div>
            <MudText Typo="Typo.caption" Class="mt-2">
                @_processMessage
            </MudText>
            <MudButton Variant="Variant.Outlined"
                       Class="mt-7"
                       Size="Size.Small"
                       Disabled="@(_isWorking || _cacheLength==0)"
                       OnClick="ClearCacheAsync">全部清理</MudButton>

            <MudButton Variant="Variant.Outlined"
                       Class="mt-4"
                       Size="Size.Small"
                       Disabled="@(_isWorking || _cacheLength==0)"
                       OnClick="ClearErrorCacheAsync">修复不可用缓存</MudButton>
            <MudText Typo="Typo.caption" Class="mt-2">
                清理老版本中部分无法播放的歌曲
            </MudText>
        </div>
    }

</div>
@code {
    private double? _cacheLength;
    private bool _isWorking = false;
    private string _processMessage = "";
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        await CalcCacheAsync();
    }

    private async Task CalcCacheAsync()
    {
        _isWorking = true;
        _cacheLength = null;
        _processMessage = "正在计算...";
        await Task.Run(async () =>
        {
            _cacheLength = 0;
            var files = Directory.GetFiles(GlobalPath.MusicCacheDirectory);
            foreach (var file in files)
            {
                var fi = new FileInfo(file);
                _cacheLength += fi.Length;
                await InvokeAsync(StateHasChanged);
            }
            _processMessage = "计算完成";
            _isWorking = false;
            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task ClearCacheAsync()
    {
        bool? result = await DialogService.ShowMessageBox("", "确定要删除吗？删除后不可恢复。", yesText: "确定", cancelText: "取消");
        if (result == null || result.Value == false)
        {
            return;
        }
        _isWorking = true;
        _processMessage = "正在清理....";
        await Task.Run(async () =>
        {
            var files = Directory.GetFiles(GlobalPath.MusicCacheDirectory);
            foreach (var file in files)
            {
                try
                {
                    var fi = new FileInfo(file);
                    _cacheLength -= fi.Length;
                    File.Delete(file);
                    await InvokeAsync(StateHasChanged);
                }
                catch (Exception ex)
                {
                    Logger.Error("缓存文件删除失败。", ex);
                }
            }
            _processMessage = "缓存已全部清理";
            _isWorking = false;
            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task ClearErrorCacheAsync()
    {
        _isWorking = true;
        _processMessage = "正在清理....";
        await Task.Run(async () =>
        {
            var files = Directory.GetFiles(GlobalPath.MusicCacheDirectory);
            foreach (var file in files)
            {
                try
                {
                    var md5 = JiuLing.CommonLibs.Security.MD5Utils.GetFileValueToLower(file);
                    if (md5 != "43fe5f6460e49afdf0bc2340012fe7b5")
                    {
                        continue;
                    }
                    var fi = new FileInfo(file);
                    _cacheLength -= fi.Length;
                    File.Delete(file);
                    await InvokeAsync(StateHasChanged);
                }
                catch (Exception ex)
                {
                    Logger.Error("缓存文件删除失败。", ex);
                }
            }
            _processMessage = "缓存已全部清理";
            _isWorking = false;
            await InvokeAsync(StateHasChanged);
        });
    }
}
